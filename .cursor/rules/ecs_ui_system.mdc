---
description: "UISystem design e responsabilidades"
globs: ["src/ecs/systems/ui.py"]
---

# UISystem Design

## Inheritance
UISystem inherits from GameSystem abstract base class.

## Scope and Responsibility

UISystem owns **all user interaction flows and decisions**:
- Start menu navigation
- Settings menu navigation
- Reset warning dialog
- In-game key handling (pause, quit, music toggle, open settings)
- Settings application and object recreation
- Game over prompt behavior

UISystem **delegates all rendering** to RenderSystem. It never draws directly.

## Collaboration with RenderSystem

UISystem and RenderSystem have clear separation:

- **UISystem** decides WHAT to show and handles user input
- **RenderSystem** decides HOW to draw it

Example flow:
1. UISystem runs start menu loop
2. UISystem calls `renderer.draw_start_menu(items, selected_index)`
3. RenderSystem draws the menu based on parameters
4. UISystem reads input and updates selected_index
5. Repeat until user makes choice

## Public Interface

### Menu Flows

**run_start_menu() -> StartDecision**
- Runs main menu loop until user makes choice
- Returns enum: START_GAME, OPEN_SETTINGS, or QUIT
- Calls `renderer.draw_start_menu()` each frame
- Handles arrow key navigation and enter/escape

**run_settings_menu() -> SettingsResult**
- Runs settings menu loop until user confirms or cancels
- Returns data about changes: `{needs_reset: bool, canceled: bool}`
- Calls `renderer.draw_settings_menu()` each frame
- Handles arrow keys, enter, escape, and value changes

**prompt_reset_warning() -> ResetDecision**
- Shows dialog warning about game reset
- Returns enum: RESET or CANCEL
- Calls `renderer.draw_reset_warning_dialog()` each frame
- Handles left/right arrow and enter

**prompt_game_over() -> GameOverDecision**
- Shows game over screen with final score
- Returns enum: RESTART or QUIT
- Calls `renderer.draw_center_message()` with game over data
- Handles enter and escape

### In-Game Input Handling

**handle_in_game_event(event) -> list[Command]**
- Converts raw pygame events into typed commands
- Does not execute commands, only returns them
- Allows main loop to apply commands in consistent order

Returns commands like:
- `MoveCommand(dx, dy)` for direction changes
- `PauseCommand()` for pause toggle
- `QuitCommand()` for quit request
- `OpenSettingsCommand()` for menu request
- `ToggleMusicCommand()` for music toggle
- `RandomizePaletteCommand()` for color change

### Settings Application

**apply_settings(reset_objects: bool)**
- Central orchestrator for applying settings changes
- Resizes window if needed
- Reloads fonts if size changed
- Recreates snake, apples, obstacles if reset_objects is True
- Updates all relevant components to match new settings

**needs_reset() -> bool**
- Compares current settings to snapshots of critical settings
- Returns True if change requires game reset (grid size, difficulty, wall mode)
- Returns False if change is cosmetic (colors, music volume, hints)

## Private Internals

### Menu State
- `_selected_index: int` - currently selected menu item
- `_menu_items: list[str]` - menu options
- `_setting_snapshots: dict` - critical settings before changes

### Input Handling Helpers
- `_handle_menu_navigation(event)` - arrow keys, enter, escape
- `_handle_setting_change(event, field)` - modify setting value
- `_is_direction_valid(dx, dy)` - prevent 180-degree turns

### Settings Validation
- `_validate_grid_size(cols, rows)` - ensure grid fits screen
- `_validate_difficulty(level)` - ensure valid difficulty enum
- `_validate_palette(colors)` - ensure colors are valid RGB tuples

## Command Protocol

Commands are simple data classes that represent user intentions:

### MoveCommand
```
direction: (dx, dy)
purpose: change snake direction
applied by: main loop updates Velocity component
```

### PauseCommand
```
purpose: toggle pause state
applied by: main loop updates Flags.paused
```

### QuitCommand
```
purpose: exit game
applied by: main loop breaks game loop
```

### OpenSettingsCommand
```
purpose: open settings menu
applied by: main loop calls ui.run_settings_menu()
```

### ToggleMusicCommand
```
purpose: toggle background music
applied by: main loop updates MusicState.enabled, AudioSystem responds
```

### RandomizePaletteCommand
```
purpose: randomize color palette
applied by: main loop updates Palette component with random colors
```

### ApplySettingsCommand
```
reset_objects: bool
purpose: apply pending settings changes
applied by: main loop calls ui.apply_settings(reset_objects)
```

## Menu System Design

### Start Menu Items
1. Start Game
2. Settings
3. Quit

Navigation: up/down arrows, enter to select, escape to quit

### Settings Menu Structure
Declarative menu from current `kobra.py`:
- Each setting has: name, type (numeric, boolean, enum), current value, validation
- Settings are organized in categories: Display, Gameplay, Audio
- Changes are applied on confirm, discarded on cancel

Navigation: up/down to select field, left/right or type to change value, enter to confirm, escape to cancel

### Reset Warning Dialog
Shown when setting change requires game reset:
- Message: "This change requires resetting the game. Continue?"
- Options: Yes (Reset), No (Cancel)
- Navigation: left/right to select, enter to confirm

## Settings Application Flow

### Non-Reset Changes
1. User changes cosmetic setting (e.g., snake color)
2. UISystem updates Settings object
3. UISystem updates relevant components (Palette.snake_head_color)
4. Next frame renders with new color
5. No entities recreated, game continues

### Reset Changes
1. User changes critical setting (e.g., grid size)
2. UISystem detects needs_reset() is True
3. UISystem calls prompt_reset_warning()
4. If user confirms:
   - UISystem updates Settings object
   - UISystem calls apply_settings(reset_objects=True)
   - New grid dimensions applied
   - Snake, apples, obstacles recreated
   - Score and high score preserved
5. If user cancels:
   - Settings reverted to snapshot
   - No changes applied

## Interaction Order in Main Loop

Commands are applied in fixed order to ensure consistency:

1. **Process settings commands**: Apply settings before anything else
2. **Process movement commands**: Update velocity before movement system runs
3. **Process state commands**: Pause, quit, etc.
4. **Run game logic systems**: Movement, collision, scoring, etc.
5. **Process audio commands**: Toggle music, play sounds
6. **Run render systems**: Interpolation, render, UI

This order ensures:
- Settings take effect immediately
- Movement is applied to current tick
- Rendering reflects all changes

## Testing Strategy

### Unit Tests (No Window)
- Mock RenderSystem with recording mock
- Verify correct render calls with correct parameters
- Test menu navigation state machine
- Test command generation from events
- Test settings validation logic

### Integration Tests (With Mock Renderer)
- Run full menu flow, verify correct sequence of render calls
- Test reset warning triggers correctly
- Test settings changes apply to correct components

### User Acceptance Tests (Manual)
- Navigate all menus, verify visual appearance
- Change all settings, verify they apply correctly
- Trigger reset warning, verify game resets properly
- Test all keyboard shortcuts work

## Migration from Current Code

Current `kobra.py` contains UI logic mixed with rendering:

### Lines to Extract

**Start Menu** (around lines 200-250)
- Menu loop with selection state
- Arrow key handling
- Enter/escape handling
- Extract to UISystem.run_start_menu()

**Settings Menu** (around lines 250-400)
- Declarative menu structure
- Value editing logic
- Confirmation/cancel logic
- Extract to UISystem.run_settings_menu()

**Apply Settings** (around lines 400-450)
- Window resize
- Font reload
- Object recreation
- Extract to UISystem.apply_settings()

**In-Game Input** (around lines 600-650)
- Pause handling
- Quit handling
- Music toggle
- Settings menu trigger
- Extract to UISystem.handle_in_game_event()

### How to Extract
1. Create UISystem class inheriting GameSystem
2. Store RenderSystem reference in constructor
3. Move menu loops into UISystem methods
4. Replace direct rendering with renderer.draw_*() calls
5. Return decisions/commands instead of executing directly
6. Move to main loop for command application

## Design Rules for UISystem

1. **Never draw directly**: Always delegate to RenderSystem
2. **Return decisions**: Don't execute state changes, return commands
3. **Validate inputs**: Check user input is valid before returning
4. **Preserve state**: Settings changes are atomic (all or nothing)
5. **Single responsibility per method**: Each public method handles one flow
6. **No game logic**: UI decisions only, game rules in other systems
7. **Consistent navigation**: Same keys work same way in all menus
