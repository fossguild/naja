---
description: Game mechanics, logic, and behavior rules for Naja
globs:
  - "naja.py"
alwaysApply: false
---

# Naja Game Mechanics

## Core Game Rules

### Snake Behavior
- **Continuous movement**: Snake always moves in current direction
- **Grid-based**: Movement snaps to `GRID_SIZE` cells
- **Starting position**: `(GRID_SIZE, GRID_SIZE)` - top-left area
- **Starting direction**: Right (`xmov=1, ymov=0`)
- **Growth**: Snake lengthens by 1 segment per apple
- **Speed**: Increases by 10% per apple, capped at `MAX_SPEED`

### Movement Rules
- **Valid moves**: Up, Down, Left, Right (orthogonal only)
- **Movement blocking**: Can't move opposite to current direction
  - Example: If moving right, pressing left is ignored
- **Input buffering**: Single-frame input (no queue)
- **Pause/unpause**: `P` key toggles game state

### Collision Detection

#### Border Collision (Death)
```python
# Snake dies if head moves outside arena bounds
if next_x not in range(0, WIDTH) or next_y not in range(0, HEIGHT):
    self.alive = False
```

#### Self-Bite (Death)
```python
# Snake dies if head collides with any tail segment
for square in self.tail:
    if next_x == square.x and next_y == square.y:
        self.alive = False
```

#### Apple Collection
```python
# Snake collects apple if head position matches apple position
if snake.head.x == apple.x and snake.head.y == apple.y:
    snake.got_apple = True
    snake.speed = min(snake.speed * 1.1, MAX_SPEED)
    apple = Apple(snake)  # Respawn apple
```

## Game State Machine

### States
1. **Start Menu**: Initial state, shows Start Game / Settings
2. **Playing**: Active gameplay with movement and collision
3. **Paused**: Game frozen, can access settings with `M`
4. **Game Over**: Death state, shows restart prompt
5. **Settings Menu**: Modal settings screen

### State Transitions
```
Start Menu → [Start Game] → Playing
Playing → [Death] → Game Over
Game Over → [Space/Enter] → Start Menu → Playing
Playing → [P] → Paused → [P] → Playing
Playing → [M] → Settings Menu → [Enter/Esc] → Playing
Any State → [Q] → Exit
```

## Settings System

### Configurable Parameters
```python
SETTINGS = {
    "cells_per_side": int,    # 10-60: Grid dimensions
    "initial_speed": float,   # 1.0-40.0: Starting speed
    "max_speed": float,       # 4.0-60.0: Speed cap
    "death_sound": bool,      # True/False: Toggle sound
}
```

### Settings Application
- Changing `cells_per_side` resizes window and recreates display surface
- Changing speed settings affects current game immediately
- Settings persist during session but not saved to disk

## Scoring System

- **Score = Length of snake tail**
- Display: Large font, centered at top (line 627)
- Formula: `len(snake.tail)` (excludes head)
- No high score persistence (suggested feature)

## Apple Mechanics

### Spawn Logic
1. Random position on grid: `(x, y)` where `x, y` are multiples of `GRID_SIZE`
2. Check collision with snake head and all tail segments
3. If collision detected, try new random position
4. Loop until valid position found

### Collection
- Instant collection on head-apple position match
- Apple respawns immediately in new location
- Snake tail grows by 1 segment
- Speed increases by 10% (up to max)


### Rendering Order
1. Clear arena (fill with `ARENA_COLOR`)
2. Draw grid lines
3. Draw apple
4. Draw snake tail segments (back to front)
5. Draw snake head
6. Draw score
7. Update display with `pygame.display.update()`

## Controls Reference

### In-Game
- `↑` / `W`: Move up
- `↓` / `S`: Move down
- `←` / `A`: Move left
- `→` / `D`: Move right
- `P`: Pause/unpause
- `M`: Open settings (game pauses)
- `Q`: Quit game

### Menus
- `W` / `S` / `↑` / `↓`: Navigate menu items
- `A` / `D` / `←` / `→`: Adjust setting values
- `Enter` / `Space`: Select / Confirm
- `Esc`: Back / Cancel
- `Mouse Click`: Select menu item

### Game Over
- `Enter` / `Space`: Restart game
- `Q`: Quit application

## Performance Considerations

### Frame Rate
- Controlled by `clock.tick_busy_loop(int(snake.speed))`
- Snake speed ranges from `CLOCK_TICKS` (initial) to `MAX_SPEED`
- Higher speed = more updates per second
- `tick_busy_loop`: More accurate timing, higher CPU usage
