---
description: "RenderSystem design e responsabilidades"
globs: ["src/ecs/systems/render.py"]
---

# RenderSystem Design

## Inheritance
RenderSystem inherits from GameSystem abstract base class.

## Scope and Responsibility

RenderSystem is **read-only** with respect to game rules:
- May write temporary render cache fields (optimization)
- Never modifies logic components (Position, Velocity, Score, etc.)
- Only draws based on component data, never decides gameplay behavior

## What RenderSystem Draws

### Game Elements
- **Game board frame**: Border around play area
- **Grid**: Optional grid lines based on settings
- **Obstacles**: Static obstacles as filled rectangles
- **Apples**: Food items as circles or sprites
- **Snake**: Head and body segments with smooth interpolation
- **Walls**: Arena boundaries (visual representation)

### Visual Effects
- **Interpolation**: Smooth motion between discrete tick positions
- **Edge wrapping**: Special handling to avoid visual jump when wrapping

### UI Overlays (delegates to UISystem)
RenderSystem does NOT draw UI elements. It only draws game world elements.
UISystem handles: score, music indicator, pause overlay, center messages, hints.

## Public Interface

These are the methods that other code can call on RenderSystem:

### render_frame(dt_ms)
Main rendering method called every frame.
- Clears screen with arena background color
- Draws grid if enabled
- Draws all entities with Renderable component
- Respects layer order for proper draw ordering
- Uses interpolated positions for smooth animation

### draw_grid()
Helper to draw grid lines on the arena.
- Reads Grid component for dimensions
- Reads Palette component for grid color
- Draws vertical and horizontal lines

### draw_entity(entity_id)
Draws a single entity based on its components.
- Reads Position, Renderable, Interpolation (if present)
- Handles different shape types (rect, circle, sprite)
- Uses interpolated position if available

## Private Internals

These are implementation details not exposed to other systems:

### Text Rendering Cache
- Pre-rendered text surfaces for common strings
- Cleared when font size or palette changes
- Reduces overhead of text rendering each frame

### Interpolation Math
- Calculates smooth position between last and current tick
- Handles edge wrapping detection (if position wrapped around grid)
- Computes alpha blending factor based on time since tick

### Shape Drawing Helpers
- `_draw_rect(surface, color, rect)`
- `_draw_circle(surface, color, center, radius)`
- `_draw_sprite(surface, sprite, position)`

### Edge Wrap Detection
- Detects if entity wrapped from right edge to left (or vice versa)
- Detects if entity wrapped from bottom edge to top (or vice versa)
- Renders entity split across edge for smooth visual transition

## Read-Only Guarantee

RenderSystem adheres to strict read-only semantics for game logic:

### What RenderSystem READS
- Position, Velocity (for interpolation direction)
- Renderable (shape, color, layer, visibility)
- SnakeBody (segment positions)
- Grid (dimensions, cell size)
- Palette (all colors)
- Interpolation (smooth positions)
- Flags (paused state, to skip interpolation)

### What RenderSystem NEVER WRITES
- Position (movement is handled by MovementSystem)
- Velocity (input is handled by InputSystem)
- Score (scoring is handled by ScoringSystem)
- SnakeBody segments (movement is handled by MovementSystem)
- Any gameplay state

### Allowed Cache Writes
RenderSystem may maintain internal caches for performance:
- Last frame dimensions (to detect resize)
- Pre-computed glyph surfaces
- Temporary interpolation values (not stored in components)

These caches are purely for rendering optimization and do not affect game logic.

## Rendering Order

Entities are drawn in order of their Renderable.layer value:

1. **Layer 0**: Background elements (walls)
2. **Layer 1**: Grid lines
3. **Layer 2**: Obstacles
4. **Layer 3**: Apples
5. **Layer 4**: Snake body
6. **Layer 5**: Snake head
7. **Layer 6+**: Reserved for future use

UISystem draws on top of all game layers (not managed by RenderSystem).

## Interpolation Handling

### Why Interpolation?
Game logic runs at fixed tick rate (e.g., 10 ticks/sec), but rendering runs at display refresh rate (e.g., 60 fps). Without interpolation, movement appears choppy.

### How It Works
1. InterpolationSystem calculates smooth position between ticks
2. RenderSystem reads interpolated position from Interpolation component
3. Draws entity at blended position: `lerp(last_pos, current_pos, alpha)`
4. Special case for edge wrapping: split render or offset to avoid jump

### Edge Wrapping Special Case
When snake wraps from right edge to left edge:
- Without special handling: snake disappears from right, reappears on left (jarring)
- With interpolation: snake smoothly slides across edge boundary
- Implementation: detect wrap, render partial snake on both edges during transition

## Performance Considerations

### Caching Strategies
- Font rendering is expensive: cache rendered text surfaces
- Color conversions: pre-calculate RGB tuples from palette
- Grid lines: could cache as single surface if grid doesn't change

### When to Clear Caches
- Font size changed in settings
- Palette changed (randomize or settings)
- Window resized
- Grid dimensions changed

### Dirty Flag Optimization
- Track if palette changed since last frame
- Track if grid changed since last frame
- Only recalculate caches when dirty flag is set

## Interaction with UISystem

RenderSystem and UISystem are separate:

- **RenderSystem**: Draws game world elements (snake, apples, grid, obstacles)
- **UISystem**: Draws overlays (score, music indicator, pause, messages)

Rendering order:
1. RenderSystem.render_frame() draws game world
2. UISystem.render_ui() draws overlays on top

Neither system calls the other directly. Main game loop calls both in sequence.

## Testing Strategy

### Unit Tests (No Window)
- Mock pygame.Surface
- Verify correct methods called with correct parameters
- Test interpolation math in isolation
- Test wrap detection logic

### Visual Regression Tests (With Window)
- Render known game state, compare screenshot to golden image
- Test edge cases: wrapping, interpolation, color changes
- Run in headless mode or offscreen buffer

### Performance Tests
- Measure frame time for different entity counts
- Verify caching reduces render time
- Profile hot paths (text rendering, blitting)

## Migration from Current Code

Current `kobra.py` contains rendering logic mixed with game logic:

### Lines to Extract
- Grid drawing code (around lines 400-450)
- Snake drawing with interpolation (around lines 500-600)
- Apple drawing (around lines 450-480)
- Obstacle drawing (around lines 480-500)
- Score rendering (handled by UISystem instead)

### How to Extract
1. Create RenderSystem class inheriting GameSystem
2. Move pure drawing code into render_frame()
3. Replace direct component access with queries
4. Keep rendering identical initially (verify with screenshots)
5. Optimize with caching as second step

## Design Rules for RenderSystem

1. **Never change game state**: RenderSystem is read-only for logic
2. **Use interpolated positions**: Read from Interpolation component, not Position directly
3. **Respect layer order**: Draw in consistent order for correct overlapping
4. **Handle missing components gracefully**: Entity might not have Interpolation, use Position
5. **Clear screen every frame**: No persistent drawing across frames
6. **Delegate UI to UISystem**: Only draw game world elements
